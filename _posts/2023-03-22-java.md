---
title: Java
author: okilwoo
date: 2023-03-22 09:10:00 +0800
categories: [Blogging, java]
tags: [java]
render_with_liquid: false
img_path: /assets/img/posts/20230322
---

## 역사와 개발 환경
Java는 Sun Microsystems에서 1991년에 제임스 고슬링과 그의 동료들이 Green Team이라는 프로젝트를 시작하면서 개발.

1995년 공식적으로 발표.

초기 목적은 가전 제품 등의 임베디드 시스템에서 사용될 수 있는 프로그래밍 언어를 만드는 것 이었음.
현재는 오라클이 Java를 관리하고 있음 (2010년 Oracle이 Sun Microsystems을 인수 )

Java 개발 환경 IDE(Integrated Development Environment)는 이클립스(Eclipse), 인텔리제이(IntelliJ), 넷빈즈(NetBeans) 등이 있음.


## 특징
- `이식성(Platform-Independence):`운영체제나 하드웨어와 무관하게 동작. Write once, run anywhere(WORA) 원칙을 따름.
- `객체 지향 프로그래밍(Object-Oriented Programming):` 객체 지향 프로그래밍 언어이고 이를 통해 모듈화, 상속, 캡슐화, 다형성 등의 개념을 적용하여 코드 재사용성을 높임.
- `안전성(Security):` 메모리 관리를 자동화하고, 강력한 보안 메커니즘을 제공.
- `멀티스레드(Multi-threaded):` 멀티스레드 프로그래밍을 지원하고 이를 통해 동시성을 제어하고, 프로그램의 성능을 향상시킬 수 있음.
- `대규모 시스템(Scalability):` 대규모 시스템에서도 사용될 수 있고 이를 위해 자바 엔터프라이즈 에디션(Java EE)과 같은 프레임워크가 제공 됨.
- `개발 생태계(Developer Ecosystem):` 다양한 라이브러리와 프레임워크, 개발 도구 등이 존재하고, 이를 활용하여 개발 생산성을 높일 수 있음. 또한 커뮤니티 지원이 활발하여 학습 자료나 지원을 받기 좋음.


## 자료형과 변수
- 기본 자료형(Primitive Types)

  | **Type** | **Contains**            | **Default** | **Size** | **Range**                                |
  | :------- | ----------------------- | :---------- | :------- | ---------------------------------------- |
  | boolean  | true 또는 false           | false       | 1 bit    | N/A                                      |
  | char     | Unicode character       | \u0000      | 16 bits  | \u0000 to  \uFFFF                        |
  | byte     | Signed integer          | 0           | 8 bits   | -128 to 127                              |
  | short    | Signed integer          | 0           | 16 bits  | -32768 to 32767                          |
  | int      | Signed integer          | 0           | 32 bits  | -2147483648 to 2147483647                |
  | long     | Signed integer          | 0L          | 64 bits  | -9223372036854775808 to<br>9223372036854775807 |
  | float    | IEEE 754 floating point | 0.0f        | 32 bits  | &plusmn;1.4E-45 to &plusmn;3.4028235E+38 |
  | double   | IEEE 754 floating point | 0.0d        | 64 bits  | &plusmn;4.9E-324 to &plusmn;1.7976931348623157E+308 |


- 참조 자료형(Reference Types)

![001](001.png)


## 연산자

| 종류      | 연산자                                      | 설명                           |
| ------- | ---------------------------------------- | ---------------------------- |
| 단항 연산자  | `++, --`                                 | 변수를 증가 또는 감소시킨 후 값을 반환합니다.   |
|         | `+ -`                                    | 부호를 변경하거나 양수/음수를 판단합니다.      |
|         | `!`                                      | 논리값을 반대로 변경합니다.              |
|         | `~`                                      | 비트를 반전합니다.                   |
| 산술 연산자  | `* / %`                                  | 곱셈, 나눗셈, 나머지를 구합니다.          |
|         | `+ -`                                    | 덧셈, 뺄셈을 수행합니다.               |
| 시프트 연산자 | `<< >>`                                  | 비트를 왼쪽 또는 오른쪽으로 이동합니다.       |
|         | `>>>`                                    | 부호 없이 오른쪽으로 비트를 이동합니다.       |
| 비트 연산자  | `&`                                      | 논리곱(AND)을 수행합니다.             |
|         | `^`                                      | 배타적 논리합(XOR)을 수행합니다.         |
|         | `|`                                      | 논리합(OR)을 수행합니다.              |
| 비교 연산자  | `< > <= >= instanceof`                   | 값을 비교하고 결과를 논리값으로 반환합니다.     |
|         | `== !=`                                  | 같은지 다른지를 비교합니다.              |
| 논리 연산자  | `&&`                                     | 논리곱(AND)을 수행합니다.             |
|         | `||`                                     | 논리합(OR)을 수행합니다.              |
| 조건 연산자  | `? :`                                    | 조건에 따라 두 값을 선택합니다.           |
| 대입 연산자  | `=, +=, -=, *=, /=, %=, &=`<br>`^=, |=, <<=, >>=, >>>=` | 변수에 값을 대입하거나 연산 결과를 대입합니다.   |
|         | `&= |= ^= <<= >>= >>>=`                  | 비트 연산 결과를 대입합니다.             |
| 기타 연산자  | `() [] .`                                | 함수 호출, 배열 참조, 객체의 속성에 접근합니다. |


## 제어문

| 종류          | 설명                                       |
| ----------- | ---------------------------------------- |
| `if-else`문  | 조건식을 판단하여 true 또는 false인 경우에<br>다른 코드 블록을 실행하는 문장 |
| `switch`문   | 다양한 case문을 비교하여<br>해당하는 case문을 실행하는 문장   |
| `for`문      | 반복문으로, 초기식, 조건식, 증감식을 지정하여<br>반복적으로 코드 블록을 실행하는 문장 |
| `while`문    | 반복문으로, 조건식을 판단하여 true인 경우에<br>반복적으로 코드 블록을 실행하는 문장 |
| `do-while`문 | 반복문으로, 먼저 코드 블록을 한 번 실행한 후<br>조건식을 판단하여 true인 경우에 반복적으로 실행하는 문장 |


## 객체 지향 프로그래밍 (OOP) 개념

| 특징                  | 설명                                       |
| ------------------- | ---------------------------------------- |
| 클래스 (Class)         | 객체를 정의하는 틀로(template), 객체의 속성과 동작을 결정한다. |
| 객체 (Object)         | 클래스의 인스턴스로, 데이터와 메서드를 가지고 있다.            |
| 상속 (inheritance)    | 부모 클래스의 속성과 메서드를 자식 클래스에서 사용할 수 있도록 한다.  |
| 다형성 (polymorphism)  | 하나의 메서드나 클래스가 다양한 방식으로 동작할 수 있도록 한다.     |
| 캡슐화 (encapsulation) | 객체의 데이터와 동작을 하나로 묶고, 외부에서의 접근을 제한하여 보호한다. |


## 클래스와 객체의 관계

클래스는(`Class`) 객체(`Object`)를 정의하기 위한 템플릿이며, 객체는 클래스의 인스턴스입니다. 클래스는 객체를 생성하는 데 사용되는 데이터와 메서드를 정의합니다. 객체는 클래스에서 정의된 데이터와 메서드를 사용할 수 있습니다.

![001](002.png)


## 상속

상속은 객체 지향 프로그래밍의 핵심 개념 중 하나로, 기존에 정의된 클래스에서 새로운 클래스를 정의할 때, 기존 클래스의 특징과 기능을 상속 받아서 확장하는 것을 말합니다. 상속을 통해 중복 코드를 피하고 코드 재사용성을 높일 수 있습니다.

| 키워드        | 설명                                       |
| ---------- | ---------------------------------------- |
| extends    | 서브클래스가 수퍼클래스를 상속받을 때 사용                  |
| super      | 서브클래스에서 수퍼클래스의 멤버를 참조할 때 사용              |
| final      | 클래스나 메서드, 변수 앞에 붙이면 더 이상 변경될 수 없는 것을 의미  |
| abstract   | 클래스나 메서드 앞에 붙여서 구현되지 않은 추상 클래스나 추상 메서드를 의미 |
| interface  | 구현되지 않은 메서드만 가진 추상 클래스를 의미               |
| implements | 인터페이스를 구현할 때 사용                          |
| instanceof | 객체가 어떤 클래스/인터페이스의 인스턴스인지 판별할 때 사용        |
| protected  | 클래스 내부와 상속받은 클래스에서만 접근 가능한 멤버를 의미        |


## 다형성

다형성(Polymorphism)은 객체 지향 프로그래밍에서 중요한 개념 중 하나입니다. 다형성은 `하나의 이름으로 다양한 동작을 수행하는 능력`을 의미합니다.

다형성을 구현하기 위해 오버로딩(Overloading)과 오버라이딩(Overriding) 두 가지 기술을 제공합니다.

|       | 오버로딩(Overloading)                     | 오버라이딩(Overriding)                        |
| ----- | ---------------------------------------- | ---------------------------------------- |
| 정의    | 하나의 클래스 내에 같은 이름의 메소드를<br>여러 개 정의하는 것 | 부모 클래스의 메소드를 자식 클래스에서<br>재정의하는 것 |
| 매개변수  | 매개변수의 개수, 타입, 순서가<br>다른 메소드 정의 가능       | 부모 클래스의 메소드와<br>`시그니처`(매개변수, 반환값 타입) 동일|
| 반환값   | 반환값의 타입은 오버로딩에서는<br>동일해도 상관 없음          | 반환값의 타입도 동일해야 함|
| 접근제어자 | 접근제어자는 오버로딩에서도<br>다르게 지정할 수 있음        | 오버라이딩할 때, 접근제어자는<br>부모 클래스보다 좁게 변경 불가능      |
| 예시    | `public int sum(int a, int b)`,<br> `public double sum(double a, double b)` | `public void run() { ... }`<br>(부모 클래스 메소드 재정의) |

> 참고: 위의 표에서 `시그니처`는 메소드 이름과 매개변수의 개수, 타입, 순서를 모두 포함하는 것을 의미합니다.


## 인터페이스

인터페이스(Interface)는 일종의 추상 클래스로, 구현되지 않은 메소드의 집합을 정의하며, 클래스에서 이를 구현(Implement)하도록 강제합니다.

- `추상 메소드의 집합:` 인터페이스에는 구현되지 않은 추상 메소드가 선언됩니다. 이 메소드들은 구현체에 의해 구현되어야 합니다.
- `다중 상속 가능:` 클래스는 다중 상속이 불가능하지만, 인터페이스는 다중 상속이 가능합니다. 이를 통해 한 클래스가 여러 개의 인터페이스를 구현할 수 있습니다.
- `클래스와 인터페이스 간의 연결:` 인터페이스를 구현하는 클래스는 인터페이스의 메소드를 모두 구현해야 합니다. 이를 통해 클래스와 인터페이스 간의 강력한 연결이 이루어집니다.
- `타입으로서의 인터페이스:` 인터페이스는 객체를 참조할 수 있는 타입으로 사용될 수 있습니다. 인터페이스를 사용하면 다형성(Polymorphism)을 구현할 수 있습니다.


## 예외 처리

예외 처리(Exception Handling)는 프로그램이 실행 중에 발생하는 예외 상황에 대처하기 위한 기능입니다. 예외 상황은 일반적으로 프로그램 실행 중 오류(Error)나 예기치 않은 입력(InputMismatchException) 등이 발생할 때 발생합니다.

예외 처리는 다음과 같은 키워드와 함께 사용됩니다.

- `try:` 예외가 발생할 가능성이 있는 코드 블록을 나타냅니다.
- `catch:` try 블록에서 발생한 예외를 처리하는 코드 블록을 나타냅니다.
- `finally:` 예외 발생 여부와 상관없이 항상 실행되는 코드 블록을 나타냅니다.

예외가 일어나는 원인에 따라서 두 가지 종류로 구분됩니다.

- `checked exception:` 컴파일 단계에서 예외 처리를 강제하는 예외입니다. 예를 들어, 파일 입출력에서 발생할 수 있는 FileNotFoundException 등이 이에 해당합니다.
- `unchecked exception:` 컴파일러가 예외 처리를 강제하지 않는 예외입니다. 주로 NullPointerException, ArrayIndexOutOfBoundsException 등이 이에 해당합니다.


## 스레드와 동시성

스레드(`Thread`)는 하나의 프로세스 내에서 동작하는 실행 단위를 의미합니다. 스레드를 사용하면 여러 작업을 동시에 처리할 수 있습니다. 스레드를 사용하지 않으면 모든 작업은 순차적으로 처리되며, 하나의 작업이 끝나야 다음 작업을 수행할 수 있습니다.

스레드를 사용하여 동시성(`Concurrency`)을 구현할 수 있습니다. 동시성은 여러 스레드가 동시에 실행되는 것을 의미합니다. 동시성을 구현하면 다음과 같은 이점이 있습니다.

- 시스템 자원을 효율적으로 사용할 수 있습니다.
- 빠른 응답성을 제공할 수 있습니다.
- 병렬 처리로 인해 높은 처리량을 달성할 수 있습니다.

하지만 스레드를 사용할 때에는 다음과 같은 주의사항이 있습니다.

- 스레드 간의 경쟁 상황(`Race Condition`)을 방지해야 합니다.
- 스레드 간의 상호작용(`Inter-Thread Communication`)을 처리해야 합니다.
- 스레드의 우선순위와 스케줄링 등을 고려해야 합니다.

스레드를 구현하기 위해서는 다음과 같은 방법을 사용할 수 있습니다.

1. `Thread` 클래스를 상속받아 구현
2. `Runnable` 인터페이스를 구현하여 구현된 객체를 `Thread` 생성자에 전달
3. `Callable` 인터페이스와 `Future` 인터페이스를 사용하여 구현

스레드를 사용하기 위해 다양한 기능을 제공합니다. 스레드를 생성하고 실행하는 방법, 스레드 간의 동기화, 스레드 풀(`Thread Pool`)을 구현하는 방법 등 다양한 기능을 제공합니다. 이러한 기능을 사용하여 안정적이고 효율적인 멀티스레드 프로그래밍을 구현할 수 있습니다.


## 컬렉션 프레임워크

데이터를 저장, 검색, 정렬 등을 쉽게 처리하기 위해 컬렉션 프레임워크(`Collection Framework`)를 제공합니다. 컬렉션 프레임워크는 데이터를 저장하는 컬렉션(`Collection`)과 이를 다루는 알고리즘을 제공하는 인터페이스와 클래스로 구성되어 있습니다.

컬렉션 프레임워크에는 다음과 같은 인터페이스와 클래스가 있습니다.

1. `List` : 순서가 있는 데이터를 저장하며, 중복된 데이터를 허용합니다. `ArrayList, LinkedList, Vector` 등이 있습니다.
2. `Set` : 순서가 없는 데이터를 저장하며, 중복된 데이터를 허용하지 않습니다. `HashSet, TreeSet` 등이 있습니다.
3. `Queue` : `FIFO(First In First Out)` 방식으로 데이터를 처리하는 자료구조입니다. `LinkedList, PriorityQueue` 등이 있습니다.
4. `Map` : 키와 값으로 데이터를 저장하는 자료구조입니다. `HashMap, TreeMap, LinkedHashMap` 등이 있습니다.

컬렉션 프레임워크를 사용하면 데이터의 크기에 상관없이 효율적인 데이터 처리를 할 수 있습니다. 또한 다양한 알고리즘을 제공하여 데이터 검색, 정렬 등의 처리가 쉬워집니다. 또한, 제네릭(`Generic`)을 사용하여 타입 안정성을 보장하므로 런타임 오류를 최소화할 수 있습니다.

컬렉션 프레임워크를 사용할 때에는 다음과 같은 주의사항이 있습니다.

- 데이터의 크기와 종류에 맞는 적절한 컬렉션을 선택해야 합니다.
- 동시성 문제를 고려하여 스레드에 안전한 컬렉션을 선택해야 합니다.
- 컬렉션 내의 객체들이 정렬 가능한 객체여야 정렬이 가능합니다.

컬렉션 프레임워크를 사용하는 방법은 매우 간단합니다. 우선, 사용할 컬렉션을 선택하고 인스턴스를 생성합니다. 그 다음, 해당 컬렉션에 데이터를 추가하거나 삭제하고, 필요한 경우 검색, 정렬 등의 처리를 수행합니다. 자바에서는 `for-each` 루프, `Iterator, Stream` 등 다양한 방법으로 컬렉션을 처리할 수 있습니다.